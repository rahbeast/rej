<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Visualizer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .start-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .clear-btn {
            background: linear-gradient(45deg, #f44336, #da190b);
            color: white;
        }

        .algo-btn {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
        }

        .algo-btn.active {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 152, 0, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .grid-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        #grid {
            border: 3px solid #333;
            border-radius: 10px;
            cursor: crosshair;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
            border-radius: 3px;
        }

        .status {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            font-weight: 500;
            min-height: 20px;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .instructions {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }

        .instructions h3 {
            margin-top: 0;
            color: #333;
        }

        .instructions ol {
            margin: 10px 0;
            padding-left: 20px;
        }

        .algorithm-info {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Algorithm Visualizer</h1>
        
        <div class="instructions">
            <h3>How to use:</h3>
            <ol>
                <li>Click once to place the <strong style="color: green;">start</strong> point</li>
                <li>Click again to place the <strong style="color: red;">end</strong> point</li>
                <li>Click and drag to draw <strong style="color: darkblue;">walls</strong></li>
                <li>Select an algorithm and click "Start" to visualize</li>
                <li>Use "Clear" to reset the grid</li>
            </ol>
        </div>

        <div class="controls">
            <button class="algo-btn active" onclick="selectAlgorithm('dijkstra')">Dijkstra</button>
            <button class="algo-btn" onclick="selectAlgorithm('astar')">A* (A-Star)</button>
            <button class="start-btn" onclick="startVisualization()">Start Visualization</button>
            <button class="clear-btn" onclick="clearGrid()">Clear Grid</button>
        </div>

        <div id="algorithm-info" class="algorithm-info">
            <strong>Dijkstra's Algorithm:</strong> Finds the shortest path by exploring all nodes uniformly. Guarantees the optimal path but may explore more nodes than necessary.
        </div>

        <div class="grid-container">
            <canvas id="grid" width="800" height="800"></canvas>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: green;"></div>
                <span>Start</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: red;"></div>
                <span>End</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: darkblue;"></div>
                <span>Wall</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: skyblue;"></div>
                <span>Visited</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: yellow;"></div>
                <span>Path</span>
            </div>
        </div>

        <div id="status" class="status"></div>
    </div>

    <script>
        const canvas = document.getElementById('grid');
        const ctx = canvas.getContext('2d');
        const ROWS = 40;
        const GAP = 800 / ROWS;
        
        let grid = [];
        let start = null;
        let end = null;
        let walls = [];
        let isDrawing = false;
        let currentAlgorithm = 'dijkstra';
        let isRunning = false;

        // Algorithm information
        const algorithmInfo = {
            'dijkstra': '<strong>Dijkstra\'s Algorithm:</strong> Finds the shortest path by exploring all nodes uniformly. Guarantees the optimal path but may explore more nodes than necessary.',
            'astar': '<strong>A* Algorithm:</strong> Uses a heuristic (Manhattan distance) to guide the search toward the goal. Generally faster than Dijkstra and still guarantees the optimal path.'
        };

        // Pathfinding algorithms implemented in JavaScript
        function heuristic(a, b) {
            return Math.abs(a.row - b.row) + Math.abs(a.col - b.col);
        }

        function getNeighbors(node, gridData) {
            const neighbors = [];
            const directions = [
                { row: -1, col: 0 }, // up
                { row: 1, col: 0 },  // down
                { row: 0, col: -1 }, // left
                { row: 0, col: 1 }   // right
            ];

            for (const dir of directions) {
                const newRow = node.row + dir.row;
                const newCol = node.col + dir.col;
                
                if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < ROWS) {
                    const neighbor = gridData[newRow][newCol];
                    if (neighbor.type !== 'wall') {
                        neighbors.push(neighbor);
                    }
                }
            }
            return neighbors;
        }

        function dijkstraAlgorithm(gridData, startPos, endPos) {
            // Initialize distances
            for (let i = 0; i < ROWS; i++) {
                for (let j = 0; j < ROWS; j++) {
                    gridData[i][j].distance = Infinity;
                    gridData[i][j].previous = null;
                    gridData[i][j].visited = false;
                }
            }

            const startNode = gridData[startPos.row][startPos.col];
            const endNode = gridData[endPos.row][endPos.col];
            startNode.distance = 0;

            const unvisited = [];
            const visitedOrder = [];

            // Add all nodes to unvisited
            for (let i = 0; i < ROWS; i++) {
                for (let j = 0; j < ROWS; j++) {
                    unvisited.push(gridData[i][j]);
                }
            }

            while (unvisited.length > 0) {
                // Sort by distance and get closest node
                unvisited.sort((a, b) => a.distance - b.distance);
                const current = unvisited.shift();

                if (current.distance === Infinity) break;
                if (current === endNode) break;

                current.visited = true;
                if (current.type !== 'start' && current.type !== 'end') {
                    visitedOrder.push({ row: current.row, col: current.col });
                }

                const neighbors = getNeighbors(current, gridData);
                for (const neighbor of neighbors) {
                    if (!neighbor.visited) {
                        const tentativeDistance = current.distance + 1;
                        if (tentativeDistance < neighbor.distance) {
                            neighbor.distance = tentativeDistance;
                            neighbor.previous = current;
                        }
                    }
                }
            }

            // Reconstruct path
            const path = [];
            let current = endNode;
            while (current) {
                path.unshift({ row: current.row, col: current.col });
                current = current.previous;
            }

            return {
                success: path.length > 1,
                path: path.length > 1 ? path : [],
                visited: visitedOrder,
                message: path.length > 1 ? "Path found!" : "No path found!"
            };
        }

        function aStarAlgorithm(gridData, startPos, endPos) {
            // Initialize scores
            for (let i = 0; i < ROWS; i++) {
                for (let j = 0; j < ROWS; j++) {
                    gridData[i][j].gScore = Infinity;
                    gridData[i][j].fScore = Infinity;
                    gridData[i][j].previous = null;
                }
            }

            const startNode = gridData[startPos.row][startPos.col];
            const endNode = gridData[endPos.row][endPos.col];
            
            startNode.gScore = 0;
            startNode.fScore = heuristic(startNode, endNode);

            const openSet = [startNode];
            const visitedOrder = [];

            while (openSet.length > 0) {
                // Get node with lowest fScore
                openSet.sort((a, b) => a.fScore - b.fScore);
                const current = openSet.shift();

                if (current === endNode) break;

                if (current.type !== 'start' && current.type !== 'end') {
                    visitedOrder.push({ row: current.row, col: current.col });
                }

                const neighbors = getNeighbors(current, gridData);
                for (const neighbor of neighbors) {
                    const tentativeGScore = current.gScore + 1;

                    if (tentativeGScore < neighbor.gScore) {
                        neighbor.previous = current;
                        neighbor.gScore = tentativeGScore;
                        neighbor.fScore = tentativeGScore + heuristic(neighbor, endNode);

                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }

            // Reconstruct path
            const path = [];
            let current = endNode;
            while (current) {
                path.unshift({ row: current.row, col: current.col });
                current = current.previous;
            }

            return {
                success: path.length > 1,
                path: path.length > 1 ? path : [],
                visited: visitedOrder,
                message: path.length > 1 ? "Path found!" : "No path found!"
            };
        }

        // Initialize grid
        function initGrid() {
            grid = [];
            for (let i = 0; i < ROWS; i++) {
                grid[i] = [];
                for (let j = 0; j < ROWS; j++) {
                    grid[i][j] = {
                        row: i,
                        col: j,
                        type: 'empty'
                    };
                }
            }
            drawGrid();
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let i = 0; i < ROWS; i++) {
                for (let j = 0; j < ROWS; j++) {
                    const cell = grid[i][j];
                    const x = j * GAP;
                    const y = i * GAP;
                    
                    // Set colors based on cell type
                    switch (cell.type) {
                        case 'start':
                            ctx.fillStyle = 'green';
                            break;
                        case 'end':
                            ctx.fillStyle = 'red';
                            break;
                        case 'wall':
                            ctx.fillStyle = 'darkblue';
                            break;
                        case 'visited':
                            ctx.fillStyle = 'skyblue';
                            break;
                        case 'path':
                            ctx.fillStyle = 'yellow';
                            break;
                        default:
                            ctx.fillStyle = 'white';
                    }
                    
                    ctx.fillRect(x, y, GAP, GAP);
                    ctx.strokeStyle = 'gray';
                    ctx.strokeRect(x, y, GAP, GAP);
                }
            }
        }

        function getGridPosition(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const col = Math.floor(x / GAP);
            const row = Math.floor(y / GAP);
            return { row, col };
        }

        function setStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        function selectAlgorithm(algorithm) {
            if (isRunning) return;
            
            currentAlgorithm = algorithm;
            document.querySelectorAll('.algo-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update algorithm info
            const infoEl = document.getElementById('algorithm-info');
            infoEl.innerHTML = algorithmInfo[algorithm];
            
            setStatus(`${algorithm.toUpperCase()} algorithm selected`, 'info');
        }

        async function startVisualization() {
            if (isRunning || !start || !end) {
                setStatus('Please set both start and end points!', 'error');
                return;
            }
            
            isRunning = true;
            setStatus(`Running ${currentAlgorithm.toUpperCase()} algorithm...`, 'info');
            
            // Clear previous visualization
            for (let i = 0; i < ROWS; i++) {
                for (let j = 0; j < ROWS; j++) {
                    if (grid[i][j].type === 'visited' || grid[i][j].type === 'path') {
                        grid[i][j].type = 'empty';
                    }
                }
            }
            drawGrid();
            
            // Create a deep copy of grid for algorithm
            const gridCopy = grid.map(row => 
                row.map(cell => ({ ...cell }))
            );
            
            let result;
            if (currentAlgorithm === 'dijkstra') {
                result = dijkstraAlgorithm(gridCopy, start, end);
            } else {
                result = aStarAlgorithm(gridCopy, start, end);
            }
            
            if (result.success) {
                await animateVisualization(result.visited, result.path);
                setStatus(`${currentAlgorithm.toUpperCase()}: ${result.message}`, 'success');
            } else {
                setStatus(`${currentAlgorithm.toUpperCase()}: ${result.message}`, 'error');
            }
            
            isRunning = false;
        }

        async function animateVisualization(visited, path) {
            // Animate visited cells
            for (const cell of visited) {
                grid[cell.row][cell.col].type = 'visited';
                drawGrid();
                await new Promise(resolve => setTimeout(resolve, 20));
            }
            
            // Animate path
            for (const cell of path) {
                if (grid[cell.row][cell.col].type !== 'start' && grid[cell.row][cell.col].type !== 'end') {
                    grid[cell.row][cell.col].type = 'path';
                    drawGrid();
                    await new Promise(resolve => setTimeout(resolve, 80));
                }
            }
        }

        function clearGrid() {
            if (isRunning) return;
            
            start = null;
            end = null;
            walls = [];
            initGrid();
            setStatus('Grid cleared', 'info');
        }

        // Mouse event handlers
        canvas.addEventListener('mousedown', (event) => {
            if (isRunning) return;
            
            const pos = getGridPosition(event);
            const cell = grid[pos.row][pos.col];
            
            if (!start && cell.type === 'empty') {
                start = pos;
                cell.type = 'start';
                setStatus('Start point set. Click to set end point.', 'info');
            } else if (!end && cell.type === 'empty') {
                end = pos;
                cell.type = 'end';
                setStatus('End point set. Draw walls by clicking and dragging.', 'info');
            } else if (cell.type === 'empty') {
                cell.type = 'wall';
                walls.push(pos);
                isDrawing = true;
            }
            
            drawGrid();
        });

        canvas.addEventListener('mousemove', (event) => {
            if (isDrawing && !isRunning) {
                const pos = getGridPosition(event);
                const cell = grid[pos.row][pos.col];
                
                if (cell.type === 'empty') {
                    cell.type = 'wall';
                    walls.push(pos);
                    drawGrid();
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        // Initialize the application
        initGrid();
        setStatus('Click to place start point', 'info');
    </script>
</body>
</html>